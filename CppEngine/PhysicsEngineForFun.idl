%module PhysicsEngineForFun

%include <std_vector.i>

%{
	#include "ParticleWorld.h"
	#include "ParticleConstraint.h"
	#include "ParticleLink.h"
%}

struct Vector3
{
public:
	Vector3() : x(0), y(0), z(0) {}
	Vector3(const float x, const float y, const float z)
		: x(x), y(y), z(z) {}
	float x, y, z;
};

class Particle
{
public:
	void SetMass(float mass);
	float GetMass() const;
	void Integrate(float duration);
	void AddForce(const Vector3 &force);

	Vector3 position;
	Vector3 velocity;
	Vector3 acceleration;
	float damping;
};

class ParticleContact
{
public:
	void Resolve(float duration);
	float CalculateSeparatingVelocity() const;
	float restitutionCoefficient;
	float penetrationDepth;
	Vector3 contactNormal;
	Particle * particle0, *particle1;
};

class IParticleContactGenerator
{
public:
	virtual bool AddContact(ParticleContact *contact,
	unsigned int limit) const = 0;
};

class ParticleLink : public IParticleContactGenerator
{
public:
	float GetCurrentLength() const;
	virtual bool AddContact(ParticleContact *contact,
	unsigned int limit) const = 0;
	Particle * particle0, *particle1;
};

class ParticleCable : public ParticleLink
{
public:
	virtual bool AddContact(ParticleContact *contact,
	unsigned int limit) const;
	float maxLength;
	float restitutionCoefficient;
	Particle * particle0, *particle1;
};

class ParticleConnectingRod : public ParticleLink
{
public:
	virtual bool AddContact(ParticleContact *contact,
	unsigned int limit) const;
	float Length;
};

class ParticleConstraint : public IParticleContactGenerator
{
public:
	float GetCurrentLength() const;
	virtual bool AddContact(ParticleContact *contact,
		unsigned int limit) const = 0;
	Particle * particle;
	Vector3 anchorPoint;
};

class ParticleCableConstraint : public ParticleConstraint
{
public:
	virtual bool AddContact(ParticleContact *contact,
		unsigned int limit) const;
	float maxLength;
	float restitutionCoefficient;
	Particle * particle;
	Vector3 anchorPoint;
};

%template(VectorParticle) std::vector<Particle*>;
%template(VectorIParticleContactGenerator) std::vector<IParticleContactGenerator*>;
%template(VectorParticleContact) std::vector<ParticleContact*>;

class ParticleWorld
{
public:
	ParticleWorld(unsigned int maxContacts, unsigned int contactsResolverIterations = 0);
	void Start();
	void RunPhysics(float duration);
	std::vector<Particle*> particles;
	std::vector<IParticleContactGenerator*> contactGenerators;
	std::vector<ParticleContact*> contacts;
};


